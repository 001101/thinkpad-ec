#!/usr/bin/env perl
use warnings;
use strict;
#
# Read through a descriptions file on input and auto generate a list of rules
# for building the various files on output
#
# Each rule input line generates two dependancies: 
#       $filename.orig from $depname.orig using macro rule_$rule_extract
#       $depname from $filename using macro rule_$rule_insert
#

my @entries;

while(<>) {
    s/^#.*//; # remove comment lines
    next if (m/^$/);

    if (!m/^(\S+)\s+(\S+)\s+(.*)/) {
        # if we dont have three space-separated fields, skip the line
        next;
    }

    my $entry = {};
    $entry->{generator_file} = $ARGV;
    $entry->{generator_line} = $.;
    $entry->{filename} = $1;
    $entry->{tags_raw} = $2;
    $entry->{description} = $3;

    for my $tv (split(/,/,$entry->{tags_raw})) {
        my ($tag,$val_raw) = split(/:/,$tv);
        my @values = split(/;/,$val_raw);

        push @{$entry->{tags}{$tag}}, @values;
    }

    push @entries,$entry;
}

my $rules_found = 0;

my @extracts;
my @inserts;

for my $entry (@entries) {
    # only generate rules for lines that ask for them
    next if (!defined($entry->{tags}{rule}));

    # FIXME - if there is more than one rule, error?

    # currently need at least one dep defined
    next if (!defined($entry->{tags}{dep}));

    $rules_found++;

    my @deps = @{$entry->{tags}{dep}};
    my $dep0 = shift @deps;

    my @params;
    if (defined($entry->{tags}{param})) {
        @params = @{$entry->{tags}{param}};
    }

    # generate the forward rule
    my $rule = "rule_".$entry->{tags}{rule}[0]."_extract";
    push @extracts,
        sprintf("# %s:%i\n",
            $entry->{generator_file},
            $entry->{generator_line},
        ),
        sprintf("%s: %s %s %s %s\n\t\$(call %s)\n\n",
            $entry->{filename}.".orig",
            $dep0.".orig",
            join(' ',@deps),
            $entry->{generator_file},
            '$('.$rule.'_DEPS)',
            join(',',$rule,@params),
        );

    # generate the inverse rule
    $rule = "rule_".$entry->{tags}{rule}[0]."_insert";
    push @inserts,
        sprintf("# %s:%i\n",
            $entry->{generator_file},
            $entry->{generator_line},
        ),
        sprintf("%s: %s %s %s %s\n\t\$(call %s)\n\n",
            $dep0,
            $entry->{filename},
            join(' ',@deps),
            $entry->{generator_file},
            '$('.$rule.'_DEPS)',
            join(',',$rule,@params),
        );
}

if (!$rules_found) {
    # only generate output if we have at least one matching line - so an empty input
    # will just result in an empty output
    exit(0);
}

print("# autogenerated rules file - do not edit\n\n");
print(join('',@extracts));
print("\n\n");
print(join('',@inserts));

